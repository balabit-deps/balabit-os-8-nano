[Ubuntu note: adapted changes and path to old version
src/definitions -> src/nano.h
--Hlib Korzhynskyy]

Backport of:

From 5e7a3c2e7e118c7f12d5dfda9f9140f638976aa2 Mon Sep 17 00:00:00 2001
From: Benno Schulenberg <bensberg@telfort.nl>
Date: Sun, 28 Apr 2024 10:51:52 +0200
Subject: files: run `chmod` and `chown` on the descriptor, not on the filename

This closes a window of opportunity where the emergency file could be
replaced by a malicious symlink.

The issue was reported by `MartinJM` and `InvisibleMeerkat`.

Problem existed since version 2.2.0, commit 123110c5, when chmodding
and chowning of the emergency .save file was added.
---
 src/definitions.h |  2 +-
 src/files.c       | 13 ++++++++++++-
 src/nano.c        | 12 +-----------
 3 files changed, 14 insertions(+), 13 deletions(-)

Index: nano-4.8/src/files.c
===================================================================
--- nano-4.8.orig/src/files.c
+++ nano-4.8/src/files.c
@@ -1498,6 +1498,8 @@ bool write_file(const char *name, FILE *
 #endif
 	char *realname;
 		/* The filename after tilde expansion. */
+	int fd = 0;
+		/* The descriptor that is assigned when opening the file. */
 	char *tempname = NULL;
 		/* The name of the temporary file we use when prepending. */
 	linestruct *line = openfile->filetop;
@@ -1726,7 +1728,6 @@ bool write_file(const char *name, FILE *
 	/* When it's not a temporary file, this is where we open or create it. */
 	if (thefile == NULL) {
 		mode_t was_mask = 0;
-		int fd;
 
 		/* When creating an emergency file, don't let others access it. */
 		if (tmp)
@@ -1821,6 +1822,16 @@ bool write_file(const char *name, FILE *
 		lineswritten++;
 	}
 
+#if !defined(NANO_TINY)
+    /* Change permissions and owner of an emergency save file to the values
+     * of the original file, but ignore any failure as we are in a hurry. */
+	if (method == EMERGENCY && fd && openfile->current_stat) {
+		IGNORE_CALL_RESULT(fchmod(fd, openfile->current_stat->st_mode));
+		IGNORE_CALL_RESULT(fchown(fd, openfile->current_stat->st_uid,
+										openfile->current_stat->st_gid));
+	}
+#endif
+
 #ifndef NANO_TINY
 	/* When prepending, append the temporary file to what we wrote above. */
 	if (method == PREPEND) {
Index: nano-4.8/src/nano.c
===================================================================
--- nano-4.8.orig/src/nano.c
+++ nano-4.8/src/nano.c
@@ -409,7 +409,7 @@ void emergency_save(const char *die_file
 	targetname = get_next_filename(die_filename, ".save");
 
 	if (*targetname != '\0')
-		failed = !write_file(targetname, NULL, TRUE, OVERWRITE, FALSE);
+		failed = !write_file(targetname, NULL, TRUE, EMERGENCY, FALSE);
 
 	if (!failed)
 		fprintf(stderr, _("\nBuffer written to %s\n"), targetname);
@@ -420,16 +420,6 @@ void emergency_save(const char *die_file
 		fprintf(stderr, _("\nBuffer not written: %s\n"),
 				_("Too many backup files?"));
 
-#ifndef NANO_TINY
-	/* Try to chmod/chown the saved file to the values of the original file,
-	 * but ignore any failure as we are in a hurry to get out. */
-	if (die_stat) {
-		IGNORE_CALL_RESULT(chmod(targetname, die_stat->st_mode));
-		IGNORE_CALL_RESULT(chown(targetname, die_stat->st_uid,
-												die_stat->st_gid));
-	}
-#endif
-
 	free(targetname);
 }
 
Index: nano-4.8/src/nano.h
===================================================================
--- nano-4.8.orig/src/nano.h
+++ nano-4.8/src/nano.h
@@ -151,7 +151,7 @@ typedef enum {
 } message_type;
 
 typedef enum {
-	OVERWRITE, APPEND, PREPEND
+	OVERWRITE, APPEND, PREPEND, EMERGENCY
 } kind_of_writing_type;
 
 typedef enum {
